<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SAC - Single-Assignment C | Interactive Demo</title>
<style>
:root {
  --bg: #0a0a0f;
  --bg-card: #12121a;
  --bg-card-hover: #1a1a28;
  --border: #2a2a3a;
  --text: #e0e0e8;
  --text-dim: #8888a0;
  --accent: #6c5ce7;
  --accent-glow: #7c6cf7;
  --accent2: #00cec9;
  --accent3: #fd79a8;
  --accent4: #ffeaa7;
  --code-bg: #0d0d15;
  --success: #00b894;
  --radius: 12px;
  --font-mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html {
  scroll-behavior: smooth;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--bg);
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  overflow-x: hidden;
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }

/* Navigation */
nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: rgba(10, 10, 15, 0.85);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
  padding: 0 2rem;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

nav .logo {
  font-weight: 800;
  font-size: 1.3rem;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: 2px;
}

nav .nav-links {
  display: flex;
  gap: 1.5rem;
  list-style: none;
}

nav .nav-links a {
  color: var(--text-dim);
  text-decoration: none;
  font-size: 0.85rem;
  transition: color 0.2s;
}

nav .nav-links a:hover { color: var(--accent2); }

@media (max-width: 768px) {
  nav .nav-links { display: none; }
}

/* Hero */
#hero {
  position: relative;
  height: 100vh;
  min-height: 600px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

#mandelbrot-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
}

.hero-overlay {
  position: relative;
  z-index: 2;
  text-align: center;
  pointer-events: none;
}

.hero-overlay h1 {
  font-size: clamp(3rem, 8vw, 6rem);
  font-weight: 900;
  letter-spacing: 6px;
  text-shadow: 0 0 60px rgba(108, 92, 231, 0.5);
  margin-bottom: 0.5rem;
}

.hero-overlay .subtitle {
  font-size: clamp(1rem, 2.5vw, 1.4rem);
  color: var(--text-dim);
  max-width: 600px;
  margin: 0 auto 2rem;
}

.hero-code {
  pointer-events: auto;
  background: rgba(10, 10, 15, 0.8);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1.2rem 1.8rem;
  text-align: left;
  display: inline-block;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  line-height: 1.7;
  color: var(--text-dim);
  max-width: 90vw;
}

.hero-code .kw { color: var(--accent); }
.hero-code .fn { color: var(--accent2); }
.hero-code .num { color: var(--accent4); }
.hero-code .cmt { color: #555570; font-style: italic; }

.hero-hint {
  position: absolute;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 2;
  color: var(--text-dim);
  font-size: 0.8rem;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 1; }
}

/* Sections */
section {
  padding: 6rem 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

section h2 {
  font-size: 2.2rem;
  font-weight: 800;
  margin-bottom: 0.5rem;
  background: linear-gradient(135deg, var(--text), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

section .section-sub {
  color: var(--text-dim);
  margin-bottom: 3rem;
  font-size: 1.05rem;
}

/* Cards */
.cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  margin-top: 2rem;
}

.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 2rem;
  transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
}

.card:hover {
  transform: translateY(-4px);
  border-color: var(--accent);
  box-shadow: 0 8px 30px rgba(108, 92, 231, 0.15);
}

.card h3 {
  font-size: 1.2rem;
  margin-bottom: 0.8rem;
  color: var(--accent2);
}

.card p { color: var(--text-dim); font-size: 0.95rem; }

.card .icon {
  font-size: 2rem;
  margin-bottom: 1rem;
  display: block;
}

/* Code block */
.code-block {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1.2rem 1.5rem;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  line-height: 1.7;
  overflow-x: auto;
  position: relative;
}

.code-block .label {
  position: absolute;
  top: 0.5rem;
  right: 0.8rem;
  font-size: 0.65rem;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 1px;
  font-family: sans-serif;
}

.kw { color: var(--accent); }
.fn { color: var(--accent2); }
.str { color: var(--success); }
.num { color: var(--accent4); }
.typ { color: var(--accent3); }
.cmt { color: #555570; font-style: italic; }
.op { color: var(--text); }

/* Array operations section */
.array-demo {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  align-items: start;
}

@media (max-width: 768px) {
  .array-demo { grid-template-columns: 1fr; }
}

.array-grid-container {
  position: relative;
  min-height: 300px;
}

.array-grid {
  display: inline-grid;
  gap: 4px;
  transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.array-cell {
  width: 52px;
  height: 52px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  font-weight: 600;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.array-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.btn {
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 0.6rem 1.2rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  font-family: var(--font-mono);
  transition: all 0.2s;
}

.btn:hover {
  border-color: var(--accent);
  background: var(--bg-card-hover);
  box-shadow: 0 0 15px rgba(108, 92, 231, 0.2);
}

.btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.dim-selector {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.dim-btn {
  background: var(--bg-card);
  border: 1px solid var(--border);
  color: var(--text-dim);
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.2s;
}

.dim-btn.active {
  background: var(--accent2);
  border-color: var(--accent2);
  color: #000;
  font-weight: 600;
}

/* Tensor comprehensions */
.tensor-demo {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

@media (max-width: 768px) {
  .tensor-demo { grid-template-columns: 1fr; }
}

.tensor-presets {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.tensor-viz {
  display: flex;
  gap: 1.5rem;
  align-items: start;
  flex-wrap: wrap;
}

.tensor-matrix {
  display: inline-grid;
  gap: 3px;
}

.tensor-cell {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  font-family: var(--font-mono);
  font-size: 0.8rem;
  font-weight: 600;
  transition: all 0.3s;
}

.tensor-arrow {
  font-size: 2rem;
  color: var(--accent);
  align-self: center;
}

/* Stencil section */
.stencil-demo {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

@media (max-width: 768px) {
  .stencil-demo { grid-template-columns: 1fr; }
}

.stencil-canvases {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.stencil-canvases canvas {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  max-width: 100%;
}

.stencil-canvases .canvas-label {
  text-align: center;
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-top: 0.5rem;
}

.kernel-display {
  display: inline-grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 3px;
  margin: 1rem 0;
}

.kernel-cell {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-family: var(--font-mono);
  font-size: 0.75rem;
  color: var(--accent4);
}

/* Parallelization */
.parallel-demo {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}

@media (max-width: 768px) {
  .parallel-demo { grid-template-columns: 1fr; }
}

.thread-bars {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
}

.thread-bar {
  display: flex;
  align-items: center;
  gap: 0.8rem;
}

.thread-bar .label {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  color: var(--text-dim);
  min-width: 80px;
}

.thread-bar .bar-track {
  flex: 1;
  height: 28px;
  background: var(--bg-card);
  border-radius: 6px;
  border: 1px solid var(--border);
  overflow: hidden;
  position: relative;
}

.thread-bar .bar-fill {
  height: 100%;
  border-radius: 5px;
  transition: width 0.1s linear;
  position: relative;
}

.thread-bar .bar-fill::after {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 20px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
}

.thread-bar .pct {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  min-width: 45px;
  text-align: right;
}

.speedup-chart {
  margin-top: 2rem;
}

.speedup-chart canvas {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  width: 100%;
}

.parallel-controls {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

/* N-Body */
.nbody-demo {
  display: grid;
  grid-template-columns: 1.2fr 0.8fr;
  gap: 2rem;
}

@media (max-width: 768px) {
  .nbody-demo { grid-template-columns: 1fr; }
}

#nbody-canvas {
  width: 100%;
  aspect-ratio: 1;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: #050508;
  cursor: grab;
}

.nbody-controls {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

.nbody-stats {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-top: 1rem;
}

/* Footer */
footer {
  text-align: center;
  padding: 3rem 2rem;
  border-top: 1px solid var(--border);
  color: var(--text-dim);
  font-size: 0.85rem;
}

footer a {
  color: var(--accent2);
  text-decoration: none;
}

/* Animations */
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(30px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in {
  opacity: 0;
  animation: fadeInUp 0.6s ease forwards;
}

.delay-1 { animation-delay: 0.1s; }
.delay-2 { animation-delay: 0.2s; }
.delay-3 { animation-delay: 0.3s; }

/* ELI5 boxes */
.eli5 {
  background: linear-gradient(135deg, rgba(253, 121, 168, 0.08), rgba(108, 92, 231, 0.08));
  border: 1px solid rgba(253, 121, 168, 0.25);
  border-left: 4px solid var(--accent3);
  border-radius: 0 var(--radius) var(--radius) 0;
  padding: 1.5rem 1.8rem;
  margin-top: 2rem;
  margin-bottom: 1rem;
  position: relative;
}

.eli5-hero {
  margin-top: 1.5rem;
  pointer-events: auto;
  max-width: 650px;
}

.eli5 .eli5-label {
  display: inline-block;
  background: var(--accent3);
  color: #000;
  font-size: 0.7rem;
  font-weight: 800;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  padding: 0.2rem 0.6rem;
  border-radius: 4px;
  margin-bottom: 0.8rem;
}

.eli5 p {
  color: var(--text);
  font-size: 0.95rem;
  line-height: 1.75;
  margin-bottom: 0.6rem;
}

.eli5 p:last-child {
  margin-bottom: 0;
}

.eli5 strong {
  color: var(--accent3);
}

.eli5 code {
  background: rgba(0,0,0,0.3);
  padding: 0.15rem 0.4rem;
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.85em;
  color: var(--accent4);
}

.eli5-compare {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  margin-top: 1rem;
}

@media (max-width: 600px) {
  .eli5-compare { grid-template-columns: 1fr; }
}

.eli5-compare-box {
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 1rem;
  border: 1px solid var(--border);
}

.eli5-compare-box .compare-label {
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 0.5rem;
}

.eli5-compare-box pre {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  line-height: 1.5;
  color: var(--text-dim);
  white-space: pre-wrap;
}

/* Divider */
.section-divider {
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--border), transparent);
  max-width: 1200px;
  margin: 0 auto;
}

/* ========== SAC Companion Styles ========== */

/* Status indicator pill */
.sac-companion-indicator {
  position: fixed;
  bottom: 1.5rem;
  right: 1.5rem;
  z-index: 200;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.8rem;
  font-family: var(--font-mono);
  backdrop-filter: blur(12px);
  transition: all 0.4s ease;
  cursor: default;
  user-select: none;
  opacity: 0;
  transform: translateY(10px);
}

.sac-companion-indicator.visible {
  opacity: 1;
  transform: translateY(0);
}

.sac-companion-indicator.connected {
  background: rgba(0, 184, 148, 0.15);
  border: 1px solid rgba(0, 184, 148, 0.4);
  color: var(--success);
}

.sac-companion-indicator.disconnected {
  background: rgba(255, 118, 117, 0.1);
  border: 1px solid rgba(255, 118, 117, 0.3);
  color: #ff7675;
}

.sac-companion-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  animation: sac-pulse 2s ease-in-out infinite;
}

.connected .sac-companion-dot {
  background: var(--success);
  box-shadow: 0 0 8px rgba(0, 184, 148, 0.6);
}

.disconnected .sac-companion-dot {
  background: #ff7675;
  box-shadow: none;
  animation: none;
}

@keyframes sac-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* "Run Full Program in SAC" button */
.sac-run-btn {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  margin-top: 0.8rem;
  padding: 0.45rem 1rem;
  background: linear-gradient(135deg, rgba(108, 92, 231, 0.2), rgba(0, 206, 201, 0.2));
  border: 1px solid rgba(108, 92, 231, 0.4);
  border-radius: 8px;
  color: var(--accent2);
  font-family: var(--font-mono);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
}

.sac-run-btn:hover {
  background: linear-gradient(135deg, rgba(108, 92, 231, 0.35), rgba(0, 206, 201, 0.35));
  border-color: var(--accent2);
  box-shadow: 0 0 15px rgba(0, 206, 201, 0.2);
}

.sac-run-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.sac-run-btn .sac-run-icon {
  font-size: 0.9rem;
}

/* Editable code block highlight */
.code-block[contenteditable="true"] {
  outline: none;
  border-color: rgba(108, 92, 231, 0.4);
  box-shadow: inset 0 0 0 1px rgba(108, 92, 231, 0.15);
}

.code-block[contenteditable="true"]:focus {
  border-color: var(--accent);
  box-shadow: inset 0 0 0 1px rgba(108, 92, 231, 0.3), 0 0 20px rgba(108, 92, 231, 0.1);
}

.code-block .editable-hint {
  position: absolute;
  top: 0.5rem;
  right: 3.5rem;
  font-size: 0.6rem;
  color: var(--accent);
  opacity: 0.6;
  font-family: sans-serif;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  pointer-events: none;
}

/* SAC output panel */
.sac-output {
  margin-top: 0.6rem;
  border-radius: var(--radius);
  padding: 1rem 1.2rem;
  font-family: var(--font-mono);
  font-size: 0.8rem;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 300px;
  overflow-y: auto;
  transition: all 0.3s ease;
  animation: fadeInUp 0.3s ease forwards;
}

.sac-output.success {
  background: rgba(0, 184, 148, 0.08);
  border: 1px solid rgba(0, 184, 148, 0.25);
  color: var(--success);
}

.sac-output.error {
  background: rgba(255, 118, 117, 0.08);
  border: 1px solid rgba(255, 118, 117, 0.25);
  color: #ff7675;
}

.sac-output.loading {
  background: rgba(108, 92, 231, 0.08);
  border: 1px solid rgba(108, 92, 231, 0.25);
  color: var(--accent);
}

.sac-output .output-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.4rem;
  border-bottom: 1px solid rgba(255,255,255,0.06);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  opacity: 0.7;
}

.sac-output .output-timing {
  font-size: 0.7rem;
  opacity: 0.6;
}

/* Real SAC benchmark button */
.sac-bench-btn {
  background: linear-gradient(135deg, rgba(0, 184, 148, 0.2), rgba(0, 206, 201, 0.3));
  border: 1px solid rgba(0, 184, 148, 0.4);
  color: var(--success);
  padding: 0.6rem 1.2rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  font-family: var(--font-mono);
  transition: all 0.2s;
}

.sac-bench-btn:hover {
  background: linear-gradient(135deg, rgba(0, 184, 148, 0.35), rgba(0, 206, 201, 0.45));
  box-shadow: 0 0 15px rgba(0, 184, 148, 0.2);
}

.sac-bench-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Output explainer text */
.sac-output .output-explainer {
  font-family: sans-serif;
  font-size: 0.72rem;
  color: var(--text-dim);
  margin-bottom: 0.6rem;
  line-height: 1.4;
  font-style: italic;
}

/* JS Demo badge on visualizations */
.js-demo-badge {
  display: inline-block;
  font-family: sans-serif;
  font-size: 0.6rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 0.2rem 0.6rem;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: rgba(42, 42, 58, 0.5);
  margin-bottom: 0.5rem;
  opacity: 0;
  animation: fadeInUp 0.3s ease forwards;
}

/* Expanded companion toast */
.sac-companion-indicator .companion-toast {
  font-family: sans-serif;
  font-size: 0.7rem;
  color: var(--text-dim);
  line-height: 1.4;
  max-width: 320px;
  margin-left: 0.3rem;
  overflow: hidden;
  transition: max-height 0.5s ease, opacity 0.5s ease, margin 0.5s ease;
}

.sac-companion-indicator .companion-toast.collapsed {
  max-height: 0;
  opacity: 0;
  margin: 0;
}

/* SAC Mode Toggle */
.sac-mode-toggle {
  display: inline-flex;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.15);
  margin-left: 0.6rem;
  font-size: 0.7rem;
  font-family: var(--font-mono);
}

.sac-mode-toggle .toggle-option {
  padding: 0.2rem 0.6rem;
  cursor: pointer;
  transition: all 0.2s;
  color: var(--text-dim);
  background: transparent;
  user-select: none;
}

.sac-mode-toggle .toggle-option:hover {
  color: var(--text);
}

.sac-mode-toggle .toggle-option.active-js {
  background: rgba(108, 92, 231, 0.3);
  color: var(--accent);
  font-weight: 600;
}

.sac-mode-toggle .toggle-option.active-sac {
  background: rgba(0, 184, 148, 0.3);
  color: var(--success);
  font-weight: 600;
}

/* SAC computing overlay */
.sac-computing-overlay {
  position: absolute;
  inset: 0;
  background: rgba(10, 10, 15, 0.75);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius);
  z-index: 10;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  color: var(--success);
  animation: fadeInUp 0.2s ease forwards;
}

.sac-computing-overlay::before {
  content: '';
  width: 16px;
  height: 16px;
  border: 2px solid var(--success);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-right: 0.5rem;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* SAC Computed badge (green variant of js-demo-badge) */
.sac-computed-badge {
  display: inline-block;
  font-family: sans-serif;
  font-size: 0.6rem;
  color: var(--success);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 0.2rem 0.6rem;
  border: 1px solid rgba(0, 184, 148, 0.4);
  border-radius: 4px;
  background: rgba(0, 184, 148, 0.12);
  margin-bottom: 0.5rem;
  opacity: 0;
  animation: fadeInUp 0.3s ease forwards;
}

/* N-body SAC compute button */
.nbody-sac-btn {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, rgba(0, 184, 148, 0.2), rgba(0, 206, 201, 0.3));
  border: 1px solid rgba(0, 184, 148, 0.4);
  border-radius: 8px;
  color: var(--success);
  font-family: var(--font-mono);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
}

.nbody-sac-btn:hover {
  background: linear-gradient(135deg, rgba(0, 184, 148, 0.35), rgba(0, 206, 201, 0.45));
  box-shadow: 0 0 15px rgba(0, 184, 148, 0.2);
}

.nbody-sac-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>
</head>
<body>

<nav>
  <div class="logo">SAC</div>
  <ul class="nav-links">
    <li><a href="#intro">About</a></li>
    <li><a href="#arrays">Arrays</a></li>
    <li><a href="#tensors">Tensors</a></li>
    <li><a href="#stencil">Stencil</a></li>
    <li><a href="#parallel">Parallel</a></li>
    <li><a href="#nbody">N-Body</a></li>
  </ul>
</nav>

<!-- Hero: Mandelbrot -->
<section id="hero">
  <canvas id="mandelbrot-canvas"></canvas>
  <div class="hero-overlay">
    <h1>SAC</h1>
    <p class="subtitle">Single-Assignment C: Functional Array Programming for High-Performance Computing</p>
    <div class="hero-code">
      <span class="cmt">// Mandelbrot in SAC &mdash; the entire computation</span><br>
      <span class="typ">complex</span>[.,.] <span class="fn">mandelbrot</span>(<span class="typ">int</span> N, <span class="typ">int</span> iters) {<br>
      &nbsp;&nbsp;plane = { [i,j] -&gt; <span class="fn">toc</span>((<span class="typ">double</span>)j/N*<span class="num">3.0</span>-<span class="num">2.0</span>, (<span class="typ">double</span>)i/N*<span class="num">2.0</span>-<span class="num">1.0</span>) };<br>
      &nbsp;&nbsp;z = <span class="fn">genarray</span>(<span class="fn">shape</span>(plane), <span class="fn">toc</span>(<span class="num">0.0</span>,<span class="num">0.0</span>));<br>
      &nbsp;&nbsp;<span class="kw">for</span> (k=<span class="num">0</span>; k&lt;iters; k++) z = z*z + plane;<br>
      &nbsp;&nbsp;<span class="kw">return</span> z;<br>
      }
    </div>
    <div class="eli5 eli5-hero">
      <div class="eli5-label">OK but what am I looking at?</div>
      <p>That trippy background? It's a <strong>Mandelbrot fractal</strong> &mdash; basically, for every pixel, you run a tiny math formula in a loop and color it based on how many loops it took to "escape." That's it. The wild part is that the SAC code above is <strong>the whole thing</strong>. No pixel loops, no color mapping code, no threading. In Python you'd need 40+ lines and it'd be slow. SAC does it in 5 lines and the compiler figures out how to blast it across all your CPU cores.</p>
    </div>
  </div>
  <div class="hero-hint">Click to pause &middot; Scroll to zoom &middot; Drag to pan</div>
</section>

<div class="section-divider"></div>

<!-- What is SAC? -->
<section id="intro">
  <h2>What is SAC?</h2>
  <p class="section-sub">
    SAC (Single-Assignment C) is a <strong>functional array programming language</strong> with C-like syntax.
    It compiles to highly optimized sequential, multi-threaded, and GPU code &mdash; automatically.
  </p>
  <div class="eli5">
    <div class="eli5-label">Plain English version</div>
    <p>You know how in PHP/Python/JS, when you need to do something to every item in an array, you write a <code>foreach</code> loop? And if you have a grid (array of arrays), you write nested loops? And if you want it fast, you cry?</p>
    <p><strong>SAC is a language where you just say "do this to the whole array" and the compiler writes all those loops for you</strong> &mdash; and makes them run on multiple CPU cores (or even a GPU) automatically. You write code that looks like C, but you never mutate variables (that's the "single-assignment" part &mdash; like <code>const</code> everything), and the compiler uses that guarantee to safely parallelize your code without you thinking about it.</p>
    <p>Think of it as: <strong>NumPy's array operations, but as an actual compiled language that runs as fast as hand-tuned C.</strong></p>
  </div>

  <div class="cards">
    <div class="card fade-in delay-1">
      <span class="icon">&#955;</span>
      <h3>Functional + Arrays</h3>
      <p>Immutable data combined with shape-polymorphic array operations. Write once, operate on arrays of any rank and shape.</p>
      <div class="eli5" style="margin-top:1rem;padding:1rem;border-left-width:3px;">
        <p style="font-size:0.88rem;"><strong>Translation:</strong> Variables never change after you set them (like <code>const</code> in JS). And if you write a function that works on a list, it automatically also works on a 2D grid, a 3D cube, whatever. No overloading, no generics &mdash; it just works.</p>
      </div>
    </div>
    <div class="card fade-in delay-2">
      <span class="icon">&#8801;</span>
      <h3>C Syntax, No Pain</h3>
      <p>Familiar C-like syntax means low learning curve. But underneath, the compiler does heavy lifting: fusion, tiling, vectorization.</p>
      <div class="eli5" style="margin-top:1rem;padding:1rem;border-left-width:3px;">
        <p style="font-size:0.88rem;"><strong>Translation:</strong> It looks like C code, so you're not learning Haskell hieroglyphics. But the compiler is doing <em>wild</em> stuff behind the scenes &mdash; like combining multiple array operations into one pass (so you don't loop through data 3 times when once would do).</p>
      </div>
    </div>
    <div class="card fade-in delay-3">
      <span class="icon">&#8644;</span>
      <h3>Auto-Parallelization</h3>
      <p>The same source code compiles to sequential, multi-threaded (pthreads), and CUDA targets. No annotations, no pragmas, no rewrites.</p>
      <div class="eli5" style="margin-top:1rem;padding:1rem;border-left-width:3px;">
        <p style="font-size:0.88rem;"><strong>Translation:</strong> You write your code once. Then you literally just change a compiler flag and it runs on 1 core, 8 cores, or your GPU. No <code>threading</code> import, no <code>async/await</code>, no race conditions to debug at 2 AM.</p>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- Interactive Array Operations -->
<section id="arrays">
  <h2>Interactive Array Operations</h2>
  <p class="section-sub">Watch SAC's rank-polymorphic operations transform arrays in real time.</p>

  <div class="eli5">
    <div class="eli5-label">What's happening here</div>
    <p>Below is a grid of numbers. Click the buttons to rearrange it. <strong>"Rank-polymorphic" just means the same function works whether you give it a 1D list, a 2D grid, or a 3D cube.</strong> In PHP, you'd write different code for each. In SAC, <code>transpose(x)</code> just works on any of them.</p>
    <p>Try switching between 1D / 2D / 3D above the grid, then click "transpose" on each one &mdash; same function, different shaped data, it just figures it out. It's like if <code>array_reverse()</code> in PHP also worked on nested arrays automatically.</p>
  </div>

  <div class="dim-selector">
    <button class="dim-btn active" data-dim="2">2D Matrix</button>
    <button class="dim-btn" data-dim="1">1D Vector</button>
    <button class="dim-btn" data-dim="3">3D Tensor</button>
  </div>

  <div class="array-demo">
    <div>
      <div class="array-controls">
        <button class="btn" data-op="transpose">transpose</button>
        <button class="btn" data-op="reverse">reverse</button>
        <button class="btn" data-op="rotate">rotate [1]</button>
        <button class="btn" data-op="take">take [3,3]</button>
        <button class="btn" data-op="drop">drop [1,1]</button>
        <button class="btn" data-op="reset">reset</button>
      </div>
      <div class="array-grid-container">
        <div class="array-grid" id="array-grid"></div>
      </div>
    </div>
    <div>
      <div class="code-block" id="array-code">
        <span class="label">SAC</span>
        <span class="cmt">// Select an operation to see the SAC code</span><br>
        <span class="typ">int</span>[*] result = <span class="fn">operation</span>(matrix);
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- Tensor Comprehensions -->
<section id="tensors">
  <h2>Tensor Comprehensions</h2>
  <p class="section-sub">SAC's with-loops are powerful tensor comprehensions that express complex array transformations concisely.</p>

  <div class="eli5">
    <div class="eli5-label">Wait, "tensor comprehension"?</div>
    <p>OK, forget the word "tensor" &mdash; it's just a fancy word for "array that might have multiple dimensions." And a "comprehension" is just a shorthand for building a new array. <strong>You know list comprehensions in Python?</strong> Like <code>[x*2 for x in my_list]</code>? This is the same idea, but for grids/matrices/cubes.</p>
    <p>The syntax <code>{ [i,j] -&gt; A[j,i] }</code> says: "make me a new 2D array where the value at position (i,j) is whatever's at position (j,i) in the original." That's a transpose &mdash; rows become columns. Click the presets below to see different operations. <strong>Each one is a single line of SAC code.</strong></p>
    <div class="eli5-compare">
      <div class="eli5-compare-box">
        <div class="compare-label" style="color: var(--accent4);">Python equivalent</div>
        <pre>result = [[A[j][i] for j in range(n)]
          for i in range(n)]</pre>
      </div>
      <div class="eli5-compare-box">
        <div class="compare-label" style="color: var(--accent2);">SAC</div>
        <pre>result = { [i,j] -> A[j,i] };</pre>
      </div>
    </div>
  </div>

  <div class="tensor-presets">
    <button class="btn active" data-preset="transpose">Transpose</button>
    <button class="btn" data-preset="diagonal">Diagonal</button>
    <button class="btn" data-preset="rowsum">Row Sums</button>
    <button class="btn" data-preset="scale">Scale &times;2</button>
    <button class="btn" data-preset="upper">Upper Triangle</button>
  </div>

  <div class="tensor-demo">
    <div>
      <div class="code-block" id="tensor-code">
        <span class="label">SAC</span>
      </div>
      <div style="margin-top:1.5rem">
        <div class="tensor-viz" id="tensor-viz"></div>
      </div>
    </div>
    <div>
      <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">
        <strong style="color: var(--accent2);">With-loops</strong> are SAC's generalization of array comprehensions.
        They describe the value at each index position, and the compiler automatically
        parallelizes the computation.
      </p>
      <div class="code-block">
        <span class="label">Syntax</span>
        <span class="cmt">// General form:</span><br>
        result = { [<span class="num">iv</span>] -&gt; <span class="fn">expr</span>(<span class="num">iv</span>) };<br><br>
        <span class="cmt">// iv = index vector</span><br>
        <span class="cmt">// The compiler infers shape from context</span><br>
        <span class="cmt">// and parallelizes across all indices</span>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- Stencil Convolution -->
<section id="stencil">
  <h2>Stencil Convolution</h2>
  <p class="section-sub">Apply image filters using SAC's elegant stencil operations. The compiler optimizes boundary handling and memory access automatically.</p>

  <div class="eli5">
    <div class="eli5-label">Convolution = Instagram filter math</div>
    <p>You know Instagram filters? Blur, sharpen, find edges? Under the hood, they all work the same way: <strong>for each pixel, look at its neighbors, multiply them by some numbers, and add them up.</strong> Those "some numbers" are the <strong>kernel</strong> &mdash; the little 3&times;3 grid you'll see below.</p>
    <p>For example, the blur kernel averages each pixel with its neighbors (making everything smoothly blend together). The edge detection kernel <em>subtracts</em> neighbors from the center, so flat areas become black and edges light up. <strong>Same code structure, different numbers in the kernel = completely different visual effect.</strong></p>
    <p>In SAC, this whole operation is one nested comprehension. In JS/Python, you'd write 4 nested for-loops and worry about array bounds. The SAC compiler handles boundaries, memory layout, and parallelization automatically.</p>
  </div>

  <div class="stencil-demo">
    <div>
      <div class="stencil-canvases">
        <div>
          <canvas id="stencil-src" width="280" height="280"></canvas>
          <div class="canvas-label">Original</div>
        </div>
        <div>
          <canvas id="stencil-dst" width="280" height="280"></canvas>
          <div class="canvas-label" id="stencil-filter-label">Filtered</div>
        </div>
      </div>
      <div style="margin-top:1rem; display:flex; gap:0.5rem; flex-wrap:wrap;">
        <button class="btn active" data-kernel="identity">Original</button>
        <button class="btn" data-kernel="blur">Blur</button>
        <button class="btn" data-kernel="sharpen">Sharpen</button>
        <button class="btn" data-kernel="edge">Edge Detect</button>
        <button class="btn" data-kernel="emboss">Emboss</button>
      </div>
      <div style="margin-top:1rem">
        <div class="kernel-display" id="kernel-display"></div>
      </div>
    </div>
    <div>
      <div class="code-block" id="stencil-code">
        <span class="label">SAC</span>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- Parallelization Demo -->
<section id="parallel">
  <h2>Parallelization Demo</h2>
  <p class="section-sub">Same Mandelbrot code, different thread counts. SAC's compiler automatically distributes work across cores &mdash; no code changes needed.</p>

  <div class="eli5">
    <div class="eli5-label">Why parallelization is a big deal</div>
    <p>Your CPU has multiple cores (probably 4-16). Most code only uses <strong>one</strong> of them. Getting code to use all of them is called parallelization, and in most languages it's a nightmare &mdash; you're dealing with threads, locks, race conditions, and bugs that only happen on Tuesdays.</p>
    <p><strong>SAC's whole trick is: because variables never change (single-assignment), the compiler can mathematically prove it's safe to split the work across cores.</strong> No data races possible. You literally just recompile with a different flag: <code>-t seq</code> for one core, <code>-t mt_pth</code> for all cores, <code>-t cuda</code> for GPU. Same source file.</p>
    <p>Click "Run Benchmark" to see this in action. It computes a Mandelbrot set and shows how splitting work across more threads speeds things up. (This is simulated in your browser, but the principle is identical to what SAC does natively.)</p>
  </div>

  <div class="parallel-demo">
    <div>
      <div class="parallel-controls">
        <button class="btn" id="parallel-start">Run Benchmark</button>
        <button class="btn" id="parallel-reset">Reset</button>
      </div>
      <div class="thread-bars" id="thread-bars"></div>
      <div class="speedup-chart">
        <canvas id="speedup-canvas" width="500" height="220"></canvas>
      </div>
    </div>
    <div>
      <div class="code-block">
        <span class="label">SAC</span>
        <span class="cmt">// Exact same source code for all targets:</span><br><br>
        <span class="cmt">// Sequential:</span><br>
        $ sac2c -t <span class="str">seq</span> mandelbrot.sac<br><br>
        <span class="cmt">// Multi-threaded (auto-parallel):</span><br>
        $ sac2c -t <span class="str">mt_pth</span> mandelbrot.sac<br><br>
        <span class="cmt">// CUDA GPU:</span><br>
        $ sac2c -t <span class="str">cuda</span> mandelbrot.sac<br><br>
        <span class="cmt">// The compiler handles decomposition,</span><br>
        <span class="cmt">// synchronization, and data movement.</span>
      </div>
      <div style="margin-top: 1.5rem;">
        <div class="code-block">
          <span class="label">Result</span>
          <span id="speedup-result" style="color: var(--accent2);">Click "Run Benchmark" to start</span>
        </div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- N-Body Simulation -->
<section id="nbody">
  <h2>N-Body Gravity Simulation</h2>
  <p class="section-sub">200 particles interacting through gravity, expressed as a concise all-pairs computation in SAC.</p>

  <div class="eli5">
    <div class="eli5-label">Space particles for people who failed physics</div>
    <p>Every dot below is a "particle" with mass, and they all pull on each other with gravity (like tiny planets). To figure out how each particle moves, you need to calculate the gravitational pull from <strong>every other particle</strong>. With 200 particles, that's 200 &times; 199 = <strong>39,800 force calculations per frame</strong>.</p>
    <p>In Python, this would be a double <code>for</code> loop and it'd be painfully slow. In SAC, the code on the right says "for each particle i, sum up the forces from all other particles j" &mdash; <strong>and the compiler parallelizes the outer loop automatically</strong>. Each particle's forces can be computed independently on different cores.</p>
    <p>Try <strong>Sequential View</strong> &mdash; it highlights particles one at a time (this is how a single-threaded program processes them). Then switch to <strong>Parallel View</strong> &mdash; all particles are processed at once. That's the SAC difference.</p>
  </div>

  <div class="nbody-demo">
    <div>
      <canvas id="nbody-canvas" width="600" height="600"></canvas>
      <div class="nbody-controls" style="margin-top:1rem">
        <button class="btn" id="nbody-mode-seq">Sequential View</button>
        <button class="btn active" id="nbody-mode-par">Parallel View</button>
        <button class="btn" id="nbody-reset">Reset</button>
      </div>
      <div class="nbody-stats" id="nbody-stats">Particles: 200 | Mode: Parallel | FPS: --</div>
    </div>
    <div>
      <div class="code-block">
        <span class="label">SAC</span>
        <span class="cmt">// All-pairs gravitational acceleration</span><br>
        <span class="typ">double</span>[n,<span class="num">3</span>] <span class="fn">accelerations</span>(<span class="typ">double</span>[n,<span class="num">3</span>] pos, <span class="typ">double</span>[n] mass) {<br>
        &nbsp;&nbsp;<span class="kw">return</span> { [i] -&gt; <span class="fn">sum</span>({<br>
        &nbsp;&nbsp;&nbsp;&nbsp;[j] -&gt; i != j<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? mass[j] * (pos[j]-pos[i])<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ <span class="fn">pow</span>(<span class="fn">norm</span>(pos[j]-pos[i]),<span class="num">3</span>)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="fn">genarray</span>([<span class="num">3</span>], <span class="num">0.0</span>)<br>
        &nbsp;&nbsp;}) };<br>
        }
      </div>
      <div style="margin-top:1.5rem">
        <p style="color: var(--text-dim); font-size: 0.9rem;">
          <strong style="color:var(--accent2)">Sequential view:</strong> highlights particles one-by-one as their forces are computed serially.<br><br>
          <strong style="color:var(--accent)">Parallel view:</strong> all forces computed simultaneously &mdash; this is what SAC's compiler achieves automatically.
        </p>
      </div>
    </div>
  </div>
</section>

<footer>
  <p>
    SAC &mdash; Single-Assignment C &middot;
    <a href="https://www.sac-home.org" target="_blank">sac-home.org</a> &middot;
    Interactive demo showcasing functional array programming
  </p>
</footer>

<script>
// ============================================================
// GLOBAL SAC MODE STATE
// ============================================================
window.__sacModeCallbacks = [];
window.__sacRegisterModeCallback = function(cb) { window.__sacModeCallbacks.push(cb); };
window.__sacGetComputeMode = function() { return 'js'; }; // overridden by companion IIFE
window.__sacCompanionUrl = 'http://localhost:7227';

// ============================================================
// MANDELBROT HERO
// ============================================================
(function() {
  const canvas = document.getElementById('mandelbrot-canvas');
  const ctx = canvas.getContext('2d');
  let W, H;
  let paused = false;
  let time = 0;
  let centerX = -0.7436447860, centerY = 0.1318252536;
  let zoom = 0.8;
  let targetZoom = 0.8;
  let panX = 0, panY = 0;
  let dragging = false, dragStartX, dragStartY, dragPanX, dragPanY;
  const maxIter = 120;

  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width = Math.floor(W * dpr / 2);
    canvas.height = Math.floor(H * dpr / 2);
  }

  function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1; if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  function render() {
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    const data = img.data;
    const aspect = w / h;
    const scale = 3.0 / zoom;
    const cx = centerX + panX / zoom;
    const cy = centerY + panY / zoom;

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const x0 = (px / w - 0.5) * scale * aspect + cx;
        const y0 = (py / h - 0.5) * scale + cy;
        let x = 0, y = 0, iter = 0;
        while (x*x + y*y <= 4 && iter < maxIter) {
          const xt = x*x - y*y + x0;
          y = 2*x*y + y0;
          x = xt;
          iter++;
        }
        const idx = (py * w + px) * 4;
        if (iter === maxIter) {
          data[idx] = data[idx+1] = data[idx+2] = 0;
        } else {
          const smooth = iter + 1 - Math.log2(Math.log2(x*x + y*y));
          const hue = (smooth * 8 + time * 40) % 360;
          const [r, g, b] = hslToRgb(hue, 85, 50 + Math.sin(smooth * 0.3) * 15);
          data[idx] = r; data[idx+1] = g; data[idx+2] = b;
        }
        data[idx+3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }

  function animate() {
    if (!paused) {
      time += 0.005;
      zoom += (targetZoom - zoom) * 0.02;
      targetZoom *= 1.001;
    }
    render();
    requestAnimationFrame(animate);
  }

  canvas.addEventListener('click', (e) => {
    if (!dragging) paused = !paused;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.85 : 1.18;
    targetZoom *= factor;
    zoom *= factor;
  }, { passive: false });

  canvas.addEventListener('mousedown', (e) => {
    dragging = false;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragPanX = panX;
    dragPanY = panY;
    canvas.style.cursor = 'grabbing';

    const onMove = (e) => {
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      if (Math.abs(dx) + Math.abs(dy) > 5) dragging = true;
      panX = dragPanX - dx * 0.002 / zoom * 3;
      panY = dragPanY - dy * 0.002 / zoom * 3;
    };
    const onUp = () => {
      canvas.style.cursor = 'crosshair';
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      setTimeout(() => { dragging = false; }, 50);
    };
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  });

  window.addEventListener('resize', () => { resize(); });
  resize();
  animate();
})();

// ============================================================
// INTERSECTION OBSERVER for fade-in
// ============================================================
const observer = new IntersectionObserver((entries) => {
  entries.forEach(e => {
    if (e.isIntersecting) e.target.classList.add('fade-in');
  });
}, { threshold: 0.1 });
document.querySelectorAll('.card').forEach(c => observer.observe(c));

// ============================================================
// ARRAY OPERATIONS
// ============================================================
(function() {
  const grid = document.getElementById('array-grid');
  const codeEl = document.getElementById('array-code');
  let currentDim = 2;
  let matrix;

  const colors = [
    '#6c5ce7','#00cec9','#fd79a8','#ffeaa7','#00b894','#e17055',
    '#74b9ff','#a29bfe','#55efc4','#fab1a0','#81ecec','#dfe6e9',
    '#ff7675','#fdcb6e','#636e72','#b2bec3'
  ];

  function makeMatrix(dim) {
    if (dim === 1) return { shape: [8], data: [1,2,3,4,5,6,7,8] };
    if (dim === 2) return { shape: [4,4], data: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] };
    return { shape: [2,3,3], data: Array.from({length:18}, (_,i) => i+1) };
  }

  function renderGrid(m) {
    grid.innerHTML = '';
    const [rows, cols] = m.shape.length === 1 ? [1, m.shape[0]]
      : m.shape.length === 2 ? m.shape
      : [m.shape[0] * m.shape[1], m.shape[2]];

    grid.style.gridTemplateColumns = `repeat(${cols}, 52px)`;
    m.data.forEach((v, i) => {
      const cell = document.createElement('div');
      cell.className = 'array-cell';
      cell.textContent = v;
      cell.style.background = colors[(v - 1) % colors.length] + '30';
      cell.style.border = `2px solid ${colors[(v - 1) % colors.length]}60`;
      cell.style.color = colors[(v - 1) % colors.length];
      cell.style.animationDelay = `${i * 20}ms`;
      cell.style.opacity = '0';
      cell.style.animation = 'fadeInUp 0.3s ease forwards';
      cell.style.animationDelay = `${i * 25}ms`;
      grid.appendChild(cell);
    });
  }

  function transpose(m) {
    if (m.shape.length === 1) return { shape: [...m.shape], data: [...m.data].reverse() };
    const [r, c] = m.shape;
    const d = [];
    for (let j = 0; j < c; j++) for (let i = 0; i < r; i++) d.push(m.data[i * c + j]);
    return { shape: [c, r], data: d };
  }

  function reverse(m) {
    if (m.shape.length === 1) return { shape: [...m.shape], data: [...m.data].reverse() };
    const [r, c] = m.shape;
    const d = [];
    for (let i = r - 1; i >= 0; i--) for (let j = 0; j < c; j++) d.push(m.data[i * c + j]);
    return { shape: [r, c], data: d };
  }

  function rotate(m) {
    if (m.shape.length === 1) {
      const d = [...m.data];
      d.push(d.shift());
      return { shape: [...m.shape], data: d };
    }
    const [r, c] = m.shape;
    const d = [];
    for (let i = 0; i < r; i++) {
      const row = m.data.slice(i * c, (i + 1) * c);
      row.push(row.shift());
      d.push(...row);
    }
    return { shape: [r, c], data: d };
  }

  function take(m) {
    if (m.shape.length === 1) return { shape: [3], data: m.data.slice(0, 3) };
    const [r, c] = m.shape;
    const tr = Math.min(3, r), tc = Math.min(3, c);
    const d = [];
    for (let i = 0; i < tr; i++) for (let j = 0; j < tc; j++) d.push(m.data[i * c + j]);
    return { shape: [tr, tc], data: d };
  }

  function drop(m) {
    if (m.shape.length === 1) return { shape: [m.shape[0] - 1], data: m.data.slice(1) };
    const [r, c] = m.shape;
    const d = [];
    for (let i = 1; i < r; i++) for (let j = 1; j < c; j++) d.push(m.data[i * c + j]);
    return { shape: [r - 1, c - 1], data: d };
  }

  const sacCode = {
    transpose: `<span class="cmt">// Transpose: swap axes</span>\n<span class="typ">int</span>[.,.] result = <span class="fn">transpose</span>(matrix);\n\n<span class="cmt">// Equivalent with-loop:</span>\nresult = { [i,j] -> matrix[j,i] };`,
    reverse: `<span class="cmt">// Reverse along first axis</span>\n<span class="typ">int</span>[.,.] result = <span class="fn">reverse</span>(matrix);`,
    rotate: `<span class="cmt">// Rotate along axis 1 by 1 position</span>\n<span class="typ">int</span>[.,.] result = <span class="fn">rotate</span>([<span class="num">1</span>], matrix);`,
    take: `<span class="cmt">// Take first 3 elements along each axis</span>\n<span class="typ">int</span>[.,.] result = <span class="fn">take</span>([<span class="num">3</span>,<span class="num">3</span>], matrix);`,
    drop: `<span class="cmt">// Drop first element along each axis</span>\n<span class="typ">int</span>[.,.] result = <span class="fn">drop</span>([<span class="num">1</span>,<span class="num">1</span>], matrix);`,
    reset: `<span class="cmt">// Original matrix</span>\n<span class="typ">int</span>[<span class="num">4</span>,<span class="num">4</span>] matrix = <span class="fn">reshape</span>([<span class="num">4</span>,<span class="num">4</span>], <span class="fn">iota</span>(<span class="num">16</span>)+<span class="num">1</span>);`
  };

  const ops = { transpose, reverse, rotate, take, drop };

  matrix = makeMatrix(2);
  renderGrid(matrix);

  function showOverlay(container, text) {
    let ov = container.querySelector('.sac-computing-overlay');
    if (!ov) {
      ov = document.createElement('div');
      ov.className = 'sac-computing-overlay';
      container.style.position = 'relative';
      container.appendChild(ov);
    }
    ov.textContent = text || 'Computing in SAC...';
    return ov;
  }
  function hideOverlay(container) {
    const ov = container.querySelector('.sac-computing-overlay');
    if (ov) ov.remove();
  }

  function applyOpJS(op) {
    if (op === 'reset') {
      matrix = makeMatrix(currentDim);
    } else if (ops[op]) {
      if (currentDim === 3) {
        const flat2d = { shape: [matrix.shape[0] * matrix.shape[1], matrix.shape[2]], data: [...matrix.data] };
        const result = ops[op](flat2d);
        matrix = { shape: [matrix.shape[0], ...result.shape.length === 1 ? [result.shape[0]] : result.shape], data: result.data };
        matrix.shape = result.shape;
      } else {
        matrix = ops[op](matrix);
      }
    }
  }

  document.querySelectorAll('.array-controls .btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const op = btn.dataset.op;
      codeEl.innerHTML = `<span class="label">SAC</span>\n` + (sacCode[op] || sacCode.reset);

      if (op === 'reset') {
        matrix = makeMatrix(currentDim);
        renderGrid(matrix);
        return;
      }

      if (window.__sacGetComputeMode() === 'sac' && ops[op]) {
        const container = grid.parentElement;
        showOverlay(container, 'Computing in SAC...');
        try {
          const resp = await fetch(window.__sacCompanionUrl + '/compute', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ operation: 'array_op', params: { op, shape: matrix.shape, data: matrix.data } }),
          });
          const data = await resp.json();
          if (data.success && data.result && data.result.shape && data.result.data) {
            matrix = data.result;
          } else {
            console.error('SAC array_op fallback:', data.error);
            applyOpJS(op);
          }
        } catch (e) {
          console.error('SAC array_op fetch error, falling back to JS:', e);
          applyOpJS(op);
        }
        hideOverlay(container);
      } else {
        applyOpJS(op);
      }
      renderGrid(matrix);
    });
  });

  document.querySelectorAll('.dim-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.dim-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentDim = parseInt(btn.dataset.dim);
      matrix = makeMatrix(currentDim);
      renderGrid(matrix);
      codeEl.innerHTML = `<span class="label">SAC</span>\n<span class="cmt">// ${currentDim}D array - same operations apply!</span>\n<span class="typ">int</span>[${'.'.repeat(currentDim).split('').join(',')}] arr = ...;`;
    });
  });

  // Register mode callback: reset on mode switch
  window.__sacRegisterModeCallback(function(mode) {
    matrix = makeMatrix(currentDim);
    renderGrid(matrix);
  });
})();

// ============================================================
// TENSOR COMPREHENSIONS
// ============================================================
(function() {
  const codeEl = document.getElementById('tensor-code');
  const vizEl = document.getElementById('tensor-viz');
  const src = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]];

  const presets = {
    transpose: {
      code: `<span class="cmt">// Transpose via tensor comprehension</span>\nresult = { [i,j] -> A[j,i] };`,
      fn: (m) => m[0].map((_, j) => m.map(row => row[j]))
    },
    diagonal: {
      code: `<span class="cmt">// Extract diagonal</span>\ndiag = { [i] -> A[i,i] };`,
      fn: (m) => [m.map((row, i) => row[i])]
    },
    rowsum: {
      code: `<span class="cmt">// Sum each row</span>\nsums = { [i] -> <span class="fn">sum</span>(A[i]) };`,
      fn: (m) => [m.map(row => row.reduce((a, b) => a + b, 0))]
    },
    scale: {
      code: `<span class="cmt">// Element-wise scale by 2</span>\nresult = { [i,j] -> <span class="num">2</span> * A[i,j] };`,
      fn: (m) => m.map(row => row.map(v => v * 2))
    },
    upper: {
      code: `<span class="cmt">// Upper triangular</span>\nresult = { [i,j] -> j >= i ? A[i,j] : <span class="num">0</span> };`,
      fn: (m) => m.map((row, i) => row.map((v, j) => j >= i ? v : 0))
    }
  };

  function renderMatrix(m, container, highlight) {
    const el = document.createElement('div');
    el.className = 'tensor-matrix';
    const cols = m[0] ? m[0].length || 1 : 1;
    el.style.gridTemplateColumns = `repeat(${cols}, 44px)`;
    const flat = m.flat();
    flat.forEach((v, i) => {
      const cell = document.createElement('div');
      cell.className = 'tensor-cell';
      cell.textContent = v;
      const intensity = Math.min(1, Math.abs(v) / 20);
      if (v === 0 && highlight) {
        cell.style.background = '#1a1a28';
        cell.style.color = '#555570';
      } else {
        cell.style.background = highlight
          ? `rgba(108, 92, 231, ${0.15 + intensity * 0.3})`
          : `rgba(0, 206, 201, ${0.15 + intensity * 0.3})`;
        cell.style.color = highlight ? '#a29bfe' : '#00cec9';
      }
      cell.style.border = `1px solid ${highlight ? 'rgba(108,92,231,0.3)' : 'rgba(0,206,201,0.3)'}`;
      el.appendChild(cell);
    });
    container.appendChild(el);
  }

  function renderViz(name, resultMatrix) {
    vizEl.innerHTML = '';
    const srcLabel = document.createElement('div');
    srcLabel.style.textAlign = 'center';
    const srcTitle = document.createElement('div');
    srcTitle.textContent = 'Input A';
    srcTitle.style.cssText = 'font-size:0.8rem;color:var(--text-dim);margin-bottom:0.5rem;';
    srcLabel.appendChild(srcTitle);
    renderMatrix(src, srcLabel, false);
    vizEl.appendChild(srcLabel);

    const arrow = document.createElement('div');
    arrow.className = 'tensor-arrow';
    arrow.innerHTML = '&#8594;';
    vizEl.appendChild(arrow);

    const dstLabel = document.createElement('div');
    dstLabel.style.textAlign = 'center';
    const dstTitle = document.createElement('div');
    dstTitle.textContent = 'Result';
    dstTitle.style.cssText = 'font-size:0.8rem;color:var(--text-dim);margin-bottom:0.5rem;';
    dstLabel.appendChild(dstTitle);
    renderMatrix(resultMatrix, dstLabel, true);
    vizEl.appendChild(dstLabel);
  }

  async function showPreset(name) {
    const p = presets[name];
    codeEl.innerHTML = `<span class="label">SAC</span>\n` + p.code;

    if (window.__sacGetComputeMode() === 'sac') {
      try {
        const resp = await fetch(window.__sacCompanionUrl + '/compute', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'tensor', params: { preset: name, matrix: src } }),
        });
        const data = await resp.json();
        if (data.success && data.result && data.result.matrix) {
          renderViz(name, data.result.matrix);
          return;
        }
        console.error('SAC tensor fallback:', data.error);
      } catch (e) {
        console.error('SAC tensor fetch error, falling back to JS:', e);
      }
    }
    renderViz(name, p.fn(src));
  }

  document.querySelectorAll('.tensor-presets .btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tensor-presets .btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      showPreset(btn.dataset.preset);
    });
  });

  window.__sacRegisterModeCallback(function(mode) {
    showPreset('transpose');
    document.querySelectorAll('.tensor-presets .btn').forEach(b => b.classList.remove('active'));
    document.querySelector('.tensor-presets .btn[data-preset="transpose"]').classList.add('active');
  });

  showPreset('transpose');
})();

// ============================================================
// STENCIL CONVOLUTION
// ============================================================
(function() {
  const srcCanvas = document.getElementById('stencil-src');
  const dstCanvas = document.getElementById('stencil-dst');
  const srcCtx = srcCanvas.getContext('2d');
  const dstCtx = dstCanvas.getContext('2d');
  const kernelDisplay = document.getElementById('kernel-display');
  const codeEl = document.getElementById('stencil-code');
  const filterLabel = document.getElementById('stencil-filter-label');
  const W = 280, H = 280;

  // Generate a sample image: colorful gradient circles
  function generateSampleImage() {
    const img = srcCtx.createImageData(W, H);
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const idx = (y * W + x) * 4;
        const cx1 = W * 0.3, cy1 = H * 0.3;
        const cx2 = W * 0.7, cy2 = H * 0.6;
        const d1 = Math.sqrt((x-cx1)**2 + (y-cy1)**2);
        const d2 = Math.sqrt((x-cx2)**2 + (y-cy2)**2);

        const r = Math.floor(128 + 127 * Math.sin(d1 * 0.05));
        const g = Math.floor(128 + 127 * Math.sin(d2 * 0.06 + 2));
        const b = Math.floor(128 + 127 * Math.sin((d1 + d2) * 0.03 + 4));

        // Add some geometric shapes
        const inCircle1 = d1 < 60;
        const inCircle2 = d2 < 50;
        const inRect = x > 100 && x < 200 && y > 120 && y < 180;
        const checker = ((Math.floor(x/20) + Math.floor(y/20)) % 2 === 0);

        if (inCircle1) {
          img.data[idx] = 220; img.data[idx+1] = 80; img.data[idx+2] = 160;
        } else if (inCircle2) {
          img.data[idx] = 80; img.data[idx+1] = 200; img.data[idx+2] = 220;
        } else if (inRect) {
          img.data[idx] = 255; img.data[idx+1] = 220; img.data[idx+2] = 100;
        } else if (checker && y > H * 0.7) {
          img.data[idx] = r * 0.5; img.data[idx+1] = g * 0.5; img.data[idx+2] = b * 0.5;
        } else {
          img.data[idx] = r; img.data[idx+1] = g; img.data[idx+2] = b;
        }
        img.data[idx+3] = 255;
      }
    }
    srcCtx.putImageData(img, 0, 0);
    return img;
  }

  const srcImg = generateSampleImage();

  const kernels = {
    identity: { name: 'Identity', k: [[0,0,0],[0,1,0],[0,0,0]], div: 1 },
    blur: { name: 'Gaussian Blur', k: [[1,2,1],[2,4,2],[1,2,1]], div: 16 },
    sharpen: { name: 'Sharpen', k: [[0,-1,0],[-1,5,-1],[0,-1,0]], div: 1 },
    edge: { name: 'Edge Detect', k: [[-1,-1,-1],[-1,8,-1],[-1,-1,-1]], div: 1 },
    emboss: { name: 'Emboss', k: [[-2,-1,0],[-1,1,1],[0,1,2]], div: 1 }
  };

  const sacCodeMap = {
    identity: `<span class="cmt">// Identity (no-op)</span>\nresult = image;`,
    blur: `<span class="cmt">// Gaussian blur stencil</span>\n<span class="typ">double</span>[.,.] kernel = \n  <span class="fn">reshape</span>([<span class="num">3</span>,<span class="num">3</span>],\n    [<span class="num">1</span>,<span class="num">2</span>,<span class="num">1</span>, <span class="num">2</span>,<span class="num">4</span>,<span class="num">2</span>, <span class="num">1</span>,<span class="num">2</span>,<span class="num">1</span>]) / <span class="num">16.0</span>;\n\nresult = { [i,j] ->\n  <span class="fn">sum</span>({ [di,dj] ->\n    image[i+di<span class="num">-1</span>, j+dj<span class="num">-1</span>] * kernel[di,dj]\n  | [di,dj] < [<span class="num">3</span>,<span class="num">3</span>] })\n};`,
    sharpen: `<span class="cmt">// Sharpen stencil</span>\n<span class="typ">double</span>[.,.] kernel =\n  <span class="fn">reshape</span>([<span class="num">3</span>,<span class="num">3</span>],\n    [<span class="num">0</span>,<span class="num">-1</span>,<span class="num">0</span>, <span class="num">-1</span>,<span class="num">5</span>,<span class="num">-1</span>, <span class="num">0</span>,<span class="num">-1</span>,<span class="num">0</span>]);\n\nresult = { [i,j] ->\n  <span class="fn">sum</span>({ [di,dj] ->\n    image[i+di<span class="num">-1</span>, j+dj<span class="num">-1</span>] * kernel[di,dj]\n  | [di,dj] < [<span class="num">3</span>,<span class="num">3</span>] })\n};`,
    edge: `<span class="cmt">// Laplacian edge detection</span>\n<span class="typ">double</span>[.,.] kernel =\n  <span class="fn">reshape</span>([<span class="num">3</span>,<span class="num">3</span>],\n    [<span class="num">-1</span>,<span class="num">-1</span>,<span class="num">-1</span>, <span class="num">-1</span>,<span class="num">8</span>,<span class="num">-1</span>, <span class="num">-1</span>,<span class="num">-1</span>,<span class="num">-1</span>]);\n\nresult = { [i,j] ->\n  <span class="fn">sum</span>({ [di,dj] ->\n    image[i+di<span class="num">-1</span>, j+dj<span class="num">-1</span>] * kernel[di,dj]\n  | [di,dj] < [<span class="num">3</span>,<span class="num">3</span>] })\n};`,
    emboss: `<span class="cmt">// Emboss stencil</span>\n<span class="typ">double</span>[.,.] kernel =\n  <span class="fn">reshape</span>([<span class="num">3</span>,<span class="num">3</span>],\n    [<span class="num">-2</span>,<span class="num">-1</span>,<span class="num">0</span>, <span class="num">-1</span>,<span class="num">1</span>,<span class="num">1</span>, <span class="num">0</span>,<span class="num">1</span>,<span class="num">2</span>]);\n\nresult = { [i,j] ->\n  <span class="fn">sum</span>({ [di,dj] ->\n    image[i+di<span class="num">-1</span>, j+dj<span class="num">-1</span>] * kernel[di,dj]\n  | [di,dj] < [<span class="num">3</span>,<span class="num">3</span>] })\n};`
  };

  function applyKernelJS(kernelName) {
    const k = kernels[kernelName];
    const src = srcImg.data;
    const dst = dstCtx.createImageData(W, H);
    const d = dst.data;

    if (kernelName === 'identity') {
      for (let i = 0; i < src.length; i++) d[i] = src[i];
    } else {
      for (let y = 1; y < H - 1; y++) {
        for (let x = 1; x < W - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                sum += src[((y+dy)*W + (x+dx))*4 + c] * k.k[dy+1][dx+1];
              }
            }
            d[(y*W+x)*4+c] = Math.max(0, Math.min(255, Math.round(sum / k.div)));
          }
          d[(y*W+x)*4+3] = 255;
        }
      }
    }
    dstCtx.putImageData(dst, 0, 0);
  }

  function renderRgbToCanvas(ctx, rgb, w, h) {
    const img = ctx.createImageData(w, h);
    for (let i = 0; i < w * h; i++) {
      img.data[i * 4] = rgb[i * 3];
      img.data[i * 4 + 1] = rgb[i * 3 + 1];
      img.data[i * 4 + 2] = rgb[i * 3 + 2];
      img.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }

  function showKernelAndCode(kernelName) {
    const k = kernels[kernelName];
    kernelDisplay.innerHTML = '';
    k.k.flat().forEach(v => {
      const cell = document.createElement('div');
      cell.className = 'kernel-cell';
      cell.textContent = v;
      if (v > 0) cell.style.color = 'var(--accent2)';
      else if (v < 0) cell.style.color = 'var(--accent3)';
      else cell.style.color = 'var(--text-dim)';
      kernelDisplay.appendChild(cell);
    });
    codeEl.innerHTML = `<span class="label">SAC</span>\n` + sacCodeMap[kernelName];
    filterLabel.textContent = k.name;
  }

  async function applyKernel(kernelName) {
    showKernelAndCode(kernelName);

    if (window.__sacGetComputeMode() === 'sac' && kernelName !== 'identity') {
      const container = dstCanvas.parentElement;
      container.style.position = 'relative';
      const ov = document.createElement('div');
      ov.className = 'sac-computing-overlay';
      ov.textContent = 'Computing in SAC...';
      container.appendChild(ov);

      try {
        const resp = await fetch(window.__sacCompanionUrl + '/compute', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'stencil', params: { kernel: kernelName, width: W, height: H } }),
        });
        const data = await resp.json();
        if (data.success && data.result) {
          const r = data.result;
          if (r.source_rgb) renderRgbToCanvas(srcCtx, r.source_rgb, r.width, r.height);
          if (r.filtered_rgb) renderRgbToCanvas(dstCtx, r.filtered_rgb, r.width, r.height);
          ov.remove();
          return;
        }
        console.error('SAC stencil fallback:', data.error);
      } catch (e) {
        console.error('SAC stencil fetch error, falling back to JS:', e);
      }
      ov.remove();
    }
    applyKernelJS(kernelName);
  }

  document.querySelectorAll('[data-kernel]').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('[data-kernel]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyKernel(btn.dataset.kernel);
    });
  });

  window.__sacRegisterModeCallback(function(mode) {
    applyKernel('identity');
    document.querySelectorAll('[data-kernel]').forEach(b => b.classList.remove('active'));
    document.querySelector('[data-kernel="identity"]').classList.add('active');
  });

  applyKernel('identity');
})();

// ============================================================
// PARALLELIZATION DEMO
// ============================================================
(function() {
  const threadBarsEl = document.getElementById('thread-bars');
  const speedupCanvas = document.getElementById('speedup-canvas');
  const speedupCtx = speedupCanvas.getContext('2d');
  const resultEl = document.getElementById('speedup-result');
  const threadCounts = [1, 2, 4, 8];
  const barColors = ['#6c5ce7', '#00cec9', '#fd79a8', '#ffeaa7'];
  let running = false;
  let progress = {};
  let times = {};
  let animId = null;

  // Initialize bars
  function initBars() {
    threadBarsEl.innerHTML = '';
    threadCounts.forEach((tc, idx) => {
      const bar = document.createElement('div');
      bar.className = 'thread-bar';
      bar.innerHTML = `
        <span class="label">${tc} thread${tc > 1 ? 's' : ''}</span>
        <div class="bar-track"><div class="bar-fill" id="bar-${tc}" style="width:0%; background:${barColors[idx]}"></div></div>
        <span class="pct" id="pct-${tc}">0%</span>
      `;
      threadBarsEl.appendChild(bar);
      progress[tc] = 0;
      times[tc] = 0;
    });
  }

  function drawSpeedupChart() {
    const dpr = window.devicePixelRatio || 1;
    const w = speedupCanvas.clientWidth;
    const h = 220;
    speedupCanvas.width = w * dpr;
    speedupCanvas.height = h * dpr;
    speedupCanvas.style.width = w + 'px';
    speedupCanvas.style.height = h + 'px';
    speedupCtx.scale(dpr, dpr);

    speedupCtx.fillStyle = '#0d0d15';
    speedupCtx.fillRect(0, 0, w, h);
    speedupCtx.strokeStyle = '#2a2a3a';
    speedupCtx.lineWidth = 1;

    const pad = { l: 50, r: 20, t: 20, b: 40 };
    const cw = w - pad.l - pad.r;
    const ch = h - pad.t - pad.b;

    // Grid
    for (let i = 0; i <= 4; i++) {
      const y = pad.t + (ch / 4) * i;
      speedupCtx.beginPath();
      speedupCtx.moveTo(pad.l, y);
      speedupCtx.lineTo(w - pad.r, y);
      speedupCtx.stroke();
      speedupCtx.fillStyle = '#8888a0';
      speedupCtx.font = '11px sans-serif';
      speedupCtx.textAlign = 'right';
      speedupCtx.fillText((8 - i * 2) + 'x', pad.l - 8, y + 4);
    }

    // Ideal line
    speedupCtx.strokeStyle = 'rgba(255,255,255,0.15)';
    speedupCtx.setLineDash([4, 4]);
    speedupCtx.beginPath();
    threadCounts.forEach((tc, idx) => {
      const x = pad.l + (idx / (threadCounts.length - 1)) * cw;
      const y = pad.t + ch - (tc / 8) * ch;
      idx === 0 ? speedupCtx.moveTo(x, y) : speedupCtx.lineTo(x, y);
    });
    speedupCtx.stroke();
    speedupCtx.setLineDash([]);

    // Labels
    speedupCtx.fillStyle = '#555570';
    speedupCtx.font = '10px sans-serif';
    speedupCtx.textAlign = 'right';
    speedupCtx.fillText('ideal', w - pad.r + 5, pad.t + ch - (8/8)*ch + 4);

    // Data
    const baseTime = times[1] || 1;
    speedupCtx.strokeStyle = '#6c5ce7';
    speedupCtx.lineWidth = 2;
    speedupCtx.beginPath();
    threadCounts.forEach((tc, idx) => {
      const x = pad.l + (idx / (threadCounts.length - 1)) * cw;
      const speedup = times[tc] > 0 ? baseTime / times[tc] : 0;
      const y = pad.t + ch - (speedup / 8) * ch;
      idx === 0 ? speedupCtx.moveTo(x, y) : speedupCtx.lineTo(x, y);
    });
    speedupCtx.stroke();

    // Dots + labels
    threadCounts.forEach((tc, idx) => {
      const x = pad.l + (idx / (threadCounts.length - 1)) * cw;
      const speedup = times[tc] > 0 ? baseTime / times[tc] : 0;
      const y = pad.t + ch - (speedup / 8) * ch;

      speedupCtx.fillStyle = barColors[idx];
      speedupCtx.beginPath();
      speedupCtx.arc(x, y, 5, 0, Math.PI * 2);
      speedupCtx.fill();

      speedupCtx.fillStyle = '#e0e0e8';
      speedupCtx.font = '11px monospace';
      speedupCtx.textAlign = 'center';
      speedupCtx.fillText(tc + 't', x, h - pad.b + 18);
      if (speedup > 0) {
        speedupCtx.fillText(speedup.toFixed(1) + 'x', x, y - 12);
      }
    });
  }

  // Mandelbrot computation for benchmarking
  function computeMandelbrotChunk(startRow, endRow, cols, rows) {
    let count = 0;
    for (let py = startRow; py < endRow; py++) {
      for (let px = 0; px < cols; px++) {
        const x0 = (px / cols) * 3.5 - 2.5;
        const y0 = (py / rows) * 2.0 - 1.0;
        let x = 0, y = 0, iter = 0;
        while (x*x + y*y <= 4 && iter < 100) {
          const xt = x*x - y*y + x0;
          y = 2*x*y + y0;
          x = xt;
          iter++;
        }
        count += iter;
      }
    }
    return count;
  }

  async function runBenchmark() {
    if (running) return;
    running = true;
    resultEl.textContent = 'Running benchmark...';
    initBars();

    const ROWS = 300, COLS = 400;

    for (const tc of threadCounts) {
      const chunkSize = Math.ceil(ROWS / tc);
      const startTime = performance.now();
      let completed = 0;

      const promises = [];
      for (let t = 0; t < tc; t++) {
        const startRow = t * chunkSize;
        const endRow = Math.min(startRow + chunkSize, ROWS);
        promises.push(new Promise(resolve => {
          // Simulate threaded execution with staggered timeouts
          const subChunks = 20;
          const rowsPerSub = Math.ceil((endRow - startRow) / subChunks);
          let sub = 0;
          function doChunk() {
            if (sub >= subChunks) { resolve(); return; }
            const sr = startRow + sub * rowsPerSub;
            const er = Math.min(sr + rowsPerSub, endRow);
            computeMandelbrotChunk(sr, er, COLS, ROWS);
            completed++;
            progress[tc] = Math.min(100, Math.round(completed / (tc * subChunks) * 100));
            document.getElementById(`bar-${tc}`).style.width = progress[tc] + '%';
            document.getElementById(`pct-${tc}`).textContent = progress[tc] + '%';
            sub++;
            setTimeout(doChunk, 0);
          }
          doChunk();
        }));
      }

      await Promise.all(promises);
      times[tc] = performance.now() - startTime;
      progress[tc] = 100;
      document.getElementById(`bar-${tc}`).style.width = '100%';
      document.getElementById(`pct-${tc}`).textContent = '100%';
      drawSpeedupChart();
    }

    const speedup = times[1] / times[8];
    resultEl.innerHTML = `Completed! 8-thread speedup: <strong>${speedup.toFixed(1)}x</strong> (${times[1].toFixed(0)}ms &rarr; ${times[8].toFixed(0)}ms)`;
    running = false;
  }

  document.getElementById('parallel-start').addEventListener('click', runBenchmark);
  document.getElementById('parallel-reset').addEventListener('click', () => {
    running = false;
    initBars();
    times = {};
    drawSpeedupChart();
    resultEl.textContent = 'Click "Run Benchmark" to start';
  });

  initBars();
  drawSpeedupChart();
  window.addEventListener('resize', drawSpeedupChart);
})();

// ============================================================
// N-BODY SIMULATION
// ============================================================
(function() {
  const canvas = document.getElementById('nbody-canvas');
  const ctx = canvas.getContext('2d');
  const statsEl = document.getElementById('nbody-stats');
  const N = 200;
  const G = 0.5;
  const DT = 0.016;
  const SOFTENING = 4.0;
  let mode = 'parallel'; // 'sequential' or 'parallel'
  let seqHighlight = 0;
  let particles = [];
  let frameCount = 0;
  let lastFpsTime = performance.now();
  let fps = 0;

  // SAC playback state
  let sacFrames = null;
  let sacFrameIdx = 0;
  let sacPlayback = false;
  let sacBtnEl = null;

  function initParticles() {
    particles = [];
    for (let i = 0; i < N; i++) {
      const angle = Math.random() * Math.PI * 2;
      const r = 80 + Math.random() * 120;
      const x = 300 + Math.cos(angle) * r + (Math.random() - 0.5) * 40;
      const y = 300 + Math.sin(angle) * r + (Math.random() - 0.5) * 40;
      const speed = 0.8 + Math.random() * 0.5;
      particles.push({
        x, y,
        vx: -Math.sin(angle) * speed + (Math.random() - 0.5) * 0.3,
        vy: Math.cos(angle) * speed + (Math.random() - 0.5) * 0.3,
        mass: 0.5 + Math.random() * 2.5,
        hue: (angle / (Math.PI * 2) * 360 + Math.random() * 30) % 360
      });
    }
    sacPlayback = false;
    sacFrames = null;
    sacFrameIdx = 0;
  }

  function step() {
    // If playing back SAC frames, use those positions
    if (sacPlayback && sacFrames && sacFrameIdx < sacFrames.length) {
      const frame = sacFrames[sacFrameIdx];
      for (let i = 0; i < Math.min(N, frame.positions.length); i++) {
        particles[i].x = frame.positions[i][0];
        particles[i].y = frame.positions[i][1];
      }
      sacFrameIdx++;
      if (sacFrameIdx >= sacFrames.length) {
        sacPlayback = false;
        sacFrames = null;
        if (sacBtnEl) sacBtnEl.textContent = 'Compute in SAC (done - resumed JS)';
      }
      return;
    }

    const ax = new Float64Array(N);
    const ay = new Float64Array(N);

    // All-pairs acceleration
    for (let i = 0; i < N; i++) {
      for (let j = 0; j < N; j++) {
        if (i === j) continue;
        const dx = particles[j].x - particles[i].x;
        const dy = particles[j].y - particles[i].y;
        const distSq = dx*dx + dy*dy + SOFTENING;
        const dist = Math.sqrt(distSq);
        const force = G * particles[j].mass / (distSq * dist);
        ax[i] += dx * force;
        ay[i] += dy * force;
      }
    }

    // Integrate
    for (let i = 0; i < N; i++) {
      particles[i].vx += ax[i] * DT;
      particles[i].vy += ay[i] * DT;
      // Damping to prevent explosion
      particles[i].vx *= 0.999;
      particles[i].vy *= 0.999;
      particles[i].x += particles[i].vx;
      particles[i].y += particles[i].vy;

      // Soft boundary
      const cx = 300, cy = 300, maxR = 280;
      const dx = particles[i].x - cx, dy = particles[i].y - cy;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d > maxR) {
        particles[i].x = cx + dx / d * maxR;
        particles[i].y = cy + dy / d * maxR;
        particles[i].vx *= -0.5;
        particles[i].vy *= -0.5;
      }
    }
  }

  function render() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.scale(dpr, dpr);
    }

    const scaleX = w / 600;
    const scaleY = h / 600;

    ctx.fillStyle = 'rgba(5, 5, 8, 0.3)';
    ctx.fillRect(0, 0, w, h);

    step();

    if (mode === 'sequential') {
      seqHighlight = (seqHighlight + 1) % N;
    }

    for (let i = 0; i < N; i++) {
      const p = particles[i];
      const px = p.x * scaleX;
      const py = p.y * scaleY;
      const radius = (1 + p.mass * 0.8) * Math.min(scaleX, scaleY);
      let alpha = 0.7;
      let glowSize = radius * 2;

      if (mode === 'sequential') {
        const dist = Math.abs(i - seqHighlight);
        const nearHighlight = dist < 5 || dist > N - 5;
        alpha = nearHighlight ? 1.0 : 0.15;
        glowSize = nearHighlight ? radius * 4 : radius;
      }

      // Green tint during SAC playback
      const hue = sacPlayback ? 160 : p.hue;

      // Glow
      const grad = ctx.createRadialGradient(px, py, 0, px, py, glowSize);
      grad.addColorStop(0, `hsla(${hue}, 80%, 65%, ${alpha * 0.6})`);
      grad.addColorStop(1, `hsla(${hue}, 80%, 65%, 0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(px, py, glowSize, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.fillStyle = `hsla(${hue}, 80%, 70%, ${alpha})`;
      ctx.beginPath();
      ctx.arc(px, py, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw connections in sequential mode
    if (mode === 'sequential') {
      const hi = seqHighlight;
      ctx.strokeStyle = 'rgba(108, 92, 231, 0.15)';
      ctx.lineWidth = 0.5;
      for (let j = 0; j < N; j++) {
        if (j === hi) continue;
        ctx.beginPath();
        ctx.moveTo(particles[hi].x * scaleX, particles[hi].y * scaleY);
        ctx.lineTo(particles[j].x * scaleX, particles[j].y * scaleY);
        ctx.stroke();
      }
    }

    frameCount++;
    const now = performance.now();
    if (now - lastFpsTime > 500) {
      fps = Math.round(frameCount / ((now - lastFpsTime) / 1000));
      frameCount = 0;
      lastFpsTime = now;
    }
    const modeLabel = sacPlayback ? 'SAC Playback' : (mode === 'parallel' ? 'Parallel' : 'Sequential');
    statsEl.textContent = `Particles: ${N} | Mode: ${modeLabel}${sacPlayback ? ` (${sacFrameIdx}/${sacFrames ? sacFrames.length : 0})` : ''} | FPS: ${fps}`;

    requestAnimationFrame(render);
  }

  // SAC batch compute
  async function computeInSac() {
    if (!sacBtnEl || sacBtnEl.disabled) return;
    sacBtnEl.disabled = true;
    const nSteps = 120;
    sacBtnEl.textContent = `Computing ${nSteps} steps in SAC...`;

    const positions = particles.map(p => [p.x, p.y]);
    const velocities = particles.map(p => [p.vx, p.vy]);
    const masses = particles.map(p => p.mass);

    try {
      const resp = await fetch(window.__sacCompanionUrl + '/compute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          operation: 'nbody',
          params: { n_particles: N, n_steps: nSteps, positions, velocities, masses, dt: DT, g: G, softening: SOFTENING },
        }),
      });
      const data = await resp.json();
      if (data.success && data.result && data.result.frames) {
        sacFrames = data.result.frames;
        sacFrameIdx = 0;
        sacPlayback = true;
        sacBtnEl.textContent = `Playing ${sacFrames.length} SAC frames...`;
        // Clear canvas for fresh playback
        const dpr = window.devicePixelRatio || 1;
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      } else {
        console.error('SAC nbody error:', data.error);
        sacBtnEl.textContent = 'SAC compute failed - try again';
      }
    } catch (e) {
      console.error('SAC nbody fetch error:', e);
      sacBtnEl.textContent = 'Connection error - try again';
    }

    sacBtnEl.disabled = false;
  }

  function addSacButton() {
    const controls = document.querySelector('.nbody-controls');
    if (!controls || controls.querySelector('.nbody-sac-btn')) return;
    sacBtnEl = document.createElement('button');
    sacBtnEl.className = 'nbody-sac-btn';
    sacBtnEl.textContent = 'Compute 120 Steps in SAC';
    sacBtnEl.addEventListener('click', computeInSac);
    controls.appendChild(sacBtnEl);
  }

  function removeSacButton() {
    if (sacBtnEl) { sacBtnEl.remove(); sacBtnEl = null; }
    sacPlayback = false;
    sacFrames = null;
  }

  document.getElementById('nbody-mode-seq').addEventListener('click', () => {
    mode = 'sequential';
    document.getElementById('nbody-mode-seq').classList.add('active');
    document.getElementById('nbody-mode-par').classList.remove('active');
    // Clear canvas for trail reset
    const dpr = window.devicePixelRatio || 1;
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
  });

  document.getElementById('nbody-mode-par').addEventListener('click', () => {
    mode = 'parallel';
    document.getElementById('nbody-mode-par').classList.add('active');
    document.getElementById('nbody-mode-seq').classList.remove('active');
    const dpr = window.devicePixelRatio || 1;
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
  });

  document.getElementById('nbody-reset').addEventListener('click', () => {
    initParticles();
    const dpr = window.devicePixelRatio || 1;
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
  });

  // Register mode callback
  window.__sacRegisterModeCallback(function(newMode) {
    if (newMode === 'sac') {
      addSacButton();
    } else {
      removeSacButton();
    }
  });

  initParticles();
  render();
})();

// ============================================================
// SAC COMPANION - Real sac2c integration
// ============================================================
(function() {
  const COMPANION_URL = 'http://localhost:7227';
  const HEALTH_INTERVAL = 10000;   // 10s heartbeat
  const HEALTH_TIMEOUT = 1500;     // 1.5s timeout
  const MAX_FAILURES = 3;

  let connected = false;
  let failCount = 0;
  let heartbeatTimer = null;
  let indicatorEl = null;
  let sacVersion = '';
  let addedButtons = [];
  let benchBtn = null;
  let computeMode = 'js'; // 'js' or 'sac'
  let toggleEl = null;

  // Override global getter
  window.__sacGetComputeMode = function() { return computeMode; };

  // ---- Indicator ----

  function createIndicator() {
    indicatorEl = document.createElement('div');
    indicatorEl.className = 'sac-companion-indicator';
    indicatorEl.innerHTML = `
      <span class="sac-companion-dot"></span>
      <span class="sac-companion-text"></span>
      <div class="sac-mode-toggle" style="display:none">
        <span class="toggle-option active-js" data-mode="js">JS</span>
        <span class="toggle-option" data-mode="sac">SAC</span>
      </div>`;
    document.body.appendChild(indicatorEl);

    toggleEl = indicatorEl.querySelector('.sac-mode-toggle');
    toggleEl.querySelectorAll('.toggle-option').forEach(opt => {
      opt.addEventListener('click', () => setComputeMode(opt.dataset.mode));
    });

    // Restore from sessionStorage
    const saved = sessionStorage.getItem('sacComputeMode');
    if (saved === 'sac') {
      computeMode = 'sac';
    }
  }

  function setComputeMode(newMode) {
    if (newMode === computeMode) return;
    computeMode = newMode;
    sessionStorage.setItem('sacComputeMode', newMode);

    // Update toggle UI
    toggleEl.querySelectorAll('.toggle-option').forEach(opt => {
      opt.classList.remove('active-js', 'active-sac');
      if (opt.dataset.mode === newMode) {
        opt.classList.add(newMode === 'sac' ? 'active-sac' : 'active-js');
      }
    });

    // Update badges
    updateBadgesForMode(newMode);

    // Notify all visualizations
    window.__sacModeCallbacks.forEach(cb => {
      try { cb(newMode); } catch(e) { console.error('Mode callback error:', e); }
    });
  }

  function showToggle() {
    if (toggleEl) {
      toggleEl.style.display = '';
      // Apply saved mode on connect
      if (computeMode === 'sac') {
        setComputeMode('sac');
      }
    }
  }

  function hideToggle() {
    if (toggleEl) toggleEl.style.display = 'none';
    if (computeMode === 'sac') {
      setComputeMode('js');
    }
  }

  function updateIndicator(isConnected, text) {
    if (!indicatorEl) return;
    indicatorEl.classList.remove('connected', 'disconnected');
    indicatorEl.classList.add(isConnected ? 'connected' : 'disconnected');
    indicatorEl.classList.add('visible');
    indicatorEl.querySelector('.sac-companion-text').textContent = text;
  }

  function hideIndicator() {
    if (indicatorEl) {
      indicatorEl.classList.remove('visible');
    }
  }

  // ---- Health check ----

  async function checkHealth() {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), HEALTH_TIMEOUT);
      const resp = await fetch(COMPANION_URL + '/health', { signal: controller.signal });
      clearTimeout(timeout);
      if (!resp.ok) throw new Error('not ok');
      const data = await resp.json();
      sacVersion = data.sac2c_version || 'sac2c';
      failCount = 0;
      if (!connected) {
        connected = true;
        onConnect();
      }
    } catch (e) {
      failCount++;
      if (connected && failCount >= MAX_FAILURES) {
        connected = false;
        onDisconnect();
      }
    }
  }

  function startHeartbeat() {
    checkHealth();
    heartbeatTimer = setInterval(checkHealth, HEALTH_INTERVAL);
  }

  // ---- Connect / Disconnect ----

  let demoBadges = [];

  const badgeTargets = [
    { selector: '.array-demo', parent: false },
    { selector: '#tensor-viz', parent: true },
    { selector: '.stencil-canvases', parent: false },
    { selector: '#nbody-canvas', parent: true },
  ];

  function addBadges() {
    badgeTargets.forEach(({ selector, parent }) => {
      let el = document.querySelector(selector);
      if (parent && el) el = el.parentElement;
      if (!el || el.querySelector('.js-demo-badge') || el.querySelector('.sac-computed-badge')) return;
      const badge = document.createElement('div');
      badge.className = computeMode === 'sac' ? 'sac-computed-badge' : 'js-demo-badge';
      badge.textContent = computeMode === 'sac' ? 'SAC Computed' : 'Interactive JS Demo';
      badge.dataset.sacBadge = 'true';
      el.insertBefore(badge, el.firstChild);
      demoBadges.push(badge);
    });
  }

  function removeBadges() {
    demoBadges.forEach(b => b.remove());
    demoBadges = [];
  }

  function updateBadgesForMode(mode) {
    demoBadges.forEach(badge => {
      if (mode === 'sac') {
        badge.className = 'sac-computed-badge';
        badge.textContent = 'SAC Computed';
      } else {
        badge.className = 'js-demo-badge';
        badge.textContent = 'Interactive JS Demo';
      }
    });
  }

  function showConnectToast() {
    if (!indicatorEl) return;
    // Remove any previous toast
    const prev = indicatorEl.querySelector('.companion-toast');
    if (prev) prev.remove();

    const toast = document.createElement('div');
    toast.className = 'companion-toast';
    toast.textContent = "SAC compiler detected \u2014 use the JS/SAC toggle to drive visualizations with real compiled SAC code.";
    indicatorEl.appendChild(toast);

    // Collapse after 8 seconds
    setTimeout(() => {
      toast.classList.add('collapsed');
      setTimeout(() => toast.remove(), 600);
    }, 8000);
  }

  function onConnect() {
    updateIndicator(true, 'SAC Runtime Connected');
    if (indicatorEl) {
      indicatorEl.title = "A real sac2c compiler is available via Docker. Toggle JS/SAC to drive visualizations with real compiled SAC code.";
    }
    showToggle();
    addRunButtons();
    addBenchmarkButton();
    addBadges();
    showConnectToast();
  }

  function onDisconnect() {
    updateIndicator(false, 'SAC Runtime Disconnected');
    if (indicatorEl) {
      indicatorEl.title = '';
    }
    hideToggle();
    removeRunButtons();
    removeBenchmarkButton();
    removeBadges();
  }

  // ---- "Run Full Program in SAC" buttons ----

  // Map section code blocks to their demo program names
  const codeBlockMap = [
    { selector: '#array-code',   name: 'array_ops_demo' },
    { selector: '#tensor-code',  name: 'tensor_demo' },
    { selector: '#stencil-code', name: 'stencil_demo' },
  ];

  function addRunButtons() {
    // Add to mapped code blocks
    codeBlockMap.forEach(({ selector, name }) => {
      const codeEl = document.querySelector(selector);
      if (!codeEl || codeEl.querySelector('.sac-run-btn')) return;

      const btn = document.createElement('button');
      btn.className = 'sac-run-btn';
      btn.innerHTML = '<span class="sac-run-icon">&#9654;</span> Run Full Program in SAC';
      btn.dataset.sacDemo = name;
      btn.addEventListener('click', () => handleRun(btn, codeEl, name));
      codeEl.parentNode.insertBefore(btn, codeEl.nextSibling);
      addedButtons.push(btn);
    });

    // Add to other .code-block elements that have SAC code
    document.querySelectorAll('.code-block').forEach(codeEl => {
      if (codeEl.querySelector('.sac-run-btn')) return;
      if (codeEl.parentNode.querySelector('.sac-run-btn')) return;
      // Only add if the code block has a SAC label and contains function-like code
      const label = codeEl.querySelector('.label');
      if (!label || label.textContent.trim() !== 'SAC') return;
      // Skip syntax/result-only blocks
      const text = codeEl.textContent;
      if (text.includes('sac2c -t') || text.includes('Click "Run') || text.includes('General form')) return;
      if (text.includes('accelerations(')) {
        // N-body code block
        const btn = document.createElement('button');
        btn.className = 'sac-run-btn';
        btn.innerHTML = '<span class="sac-run-icon">&#9654;</span> Run Full Program in SAC';
        btn.dataset.sacDemo = 'nbody_demo';
        btn.addEventListener('click', () => handleRun(btn, codeEl, 'nbody_demo'));
        codeEl.parentNode.insertBefore(btn, codeEl.nextSibling);
        addedButtons.push(btn);
      }
    });
  }

  function removeRunButtons() {
    addedButtons.forEach(btn => btn.remove());
    addedButtons = [];
    // Remove output panels
    document.querySelectorAll('.sac-output').forEach(el => el.remove());
    // Remove editable hints
    document.querySelectorAll('.editable-hint').forEach(el => el.remove());
    // Remove contenteditable
    document.querySelectorAll('.code-block[contenteditable]').forEach(el => {
      el.removeAttribute('contenteditable');
    });
  }

  // ---- Run handler ----

  async function handleRun(btn, codeEl, demoName) {
    if (btn.disabled) return;
    btn.disabled = true;
    const origHTML = btn.innerHTML;
    btn.innerHTML = '<span class="sac-run-icon">&#8987;</span> Compiling...';

    // Remove previous output
    const prevOutput = btn.parentNode.querySelector('.sac-output');
    if (prevOutput) prevOutput.remove();

    // Show loading output
    const outputEl = document.createElement('div');
    outputEl.className = 'sac-output loading';
    outputEl.innerHTML = '<div class="output-header">real sac2c output</div><div class="output-explainer">Compiling and running the full SAC program on a real sac2c compiler (running in Docker). The visualization above is a JavaScript simulation of the same concept.</div>Compiling and running...';
    btn.parentNode.insertBefore(outputEl, btn.nextSibling);

    try {
      // Always use the pre-compiled demo, since code blocks show SAC fragments, not full programs
      const resp = await fetch(COMPANION_URL + '/compile-run', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          code: getFullProgram(demoName),
          target: 'seq',
          threads: 1,
        }),
      });
      const data = await resp.json();

      outputEl.classList.remove('loading');
      if (data.success) {
        outputEl.classList.add('success');
        const timing = [];
        if (data.compile_time_ms > 0) timing.push(`compile: ${Math.round(data.compile_time_ms)}ms`);
        if (data.run_time_ms > 0) timing.push(`run: ${Math.round(data.run_time_ms)}ms`);
        outputEl.innerHTML =
          `<div class="output-header"><span>real sac2c output</span><span class="output-timing">${timing.join(' | ')}</span></div>` +
          `<div class="output-explainer">This is the actual output from compiling and running the full SAC program on a real sac2c compiler (running in Docker). The visualization above is a JavaScript simulation of the same concept.</div>` +
          escapeHtml(data.stdout || '(no output)') +
          (data.stderr ? '\n' + escapeHtml(data.stderr) : '');
      } else {
        outputEl.classList.add('error');
        outputEl.innerHTML =
          `<div class="output-header">sac2c error</div>` +
          `<div class="output-explainer">Error from compiling/running the full SAC program on a real sac2c compiler (running in Docker).</div>` +
          escapeHtml(data.error || 'Unknown error') +
          (data.stderr ? '\n\n' + escapeHtml(data.stderr) : '');
      }
    } catch (e) {
      outputEl.classList.remove('loading');
      outputEl.classList.add('error');
      outputEl.innerHTML = `<div class="output-header">connection error</div><div class="output-explainer">Could not reach the Docker-based sac2c compiler.</div>Could not reach SAC companion server.\n${escapeHtml(e.message)}`;
    }

    btn.innerHTML = origHTML;
    btn.disabled = false;
  }

  function getFullProgram(name) {
    // Send a sentinel that tells the server to use the pre-written program file
    // The server reads from /app/programs/<name>.sac
    // We send the program source so it can also accept user-edited code in the future
    const programs = {
      mandelbrot_demo: 'USE_PRECOMPILED:mandelbrot_demo',
      array_ops_demo: 'USE_PRECOMPILED:array_ops_demo',
      tensor_demo: 'USE_PRECOMPILED:tensor_demo',
      stencil_demo: 'USE_PRECOMPILED:stencil_demo',
      nbody_demo: 'USE_PRECOMPILED:nbody_demo',
      parallel_bench: 'USE_PRECOMPILED:parallel_bench',
    };
    return programs[name] || '';
  }

  // ---- Benchmark ----

  function addBenchmarkButton() {
    const controlsEl = document.querySelector('.parallel-controls');
    if (!controlsEl || controlsEl.querySelector('.sac-bench-btn')) return;

    benchBtn = document.createElement('button');
    benchBtn.className = 'sac-bench-btn';
    benchBtn.textContent = 'Run Real SAC Benchmark';
    benchBtn.addEventListener('click', handleBenchmark);
    controlsEl.appendChild(benchBtn);
  }

  function removeBenchmarkButton() {
    if (benchBtn) {
      benchBtn.remove();
      benchBtn = null;
    }
  }

  async function handleBenchmark() {
    if (!benchBtn || benchBtn.disabled) return;
    benchBtn.disabled = true;
    benchBtn.textContent = 'Running SAC benchmark...';

    const resultEl = document.getElementById('speedup-result');
    if (resultEl) resultEl.innerHTML = 'Running real SAC benchmark (compiling + executing)...';

    try {
      const resp = await fetch(COMPANION_URL + '/benchmark', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      const data = await resp.json();

      if (data.success && data.results && data.results.length > 0) {
        // Draw real SAC results on the speedup chart
        drawRealBenchmark(data.results);
        const last = data.results[data.results.length - 1];
        const first = data.results[0];
        if (resultEl) {
          resultEl.innerHTML =
            `<strong style="color:var(--success)">Real SAC:</strong> ` +
            `${last.threads}-thread speedup: <strong>${last.speedup.toFixed(2)}x</strong> ` +
            `(${first.time_ms.toFixed(0)}ms &rarr; ${last.time_ms.toFixed(0)}ms)`;
        }
      } else {
        if (resultEl) resultEl.innerHTML = `<span style="color:#ff7675">Benchmark failed: ${escapeHtml(data.error || 'unknown error')}</span>`;
      }
    } catch (e) {
      if (resultEl) resultEl.innerHTML = `<span style="color:#ff7675">Could not reach SAC companion: ${escapeHtml(e.message)}</span>`;
    }

    benchBtn.textContent = 'Run Real SAC Benchmark';
    benchBtn.disabled = false;
  }

  function drawRealBenchmark(results) {
    const speedupCanvas = document.getElementById('speedup-canvas');
    if (!speedupCanvas) return;
    const ctx = speedupCanvas.getContext('2d');

    const dpr = window.devicePixelRatio || 1;
    const w = speedupCanvas.clientWidth;
    const h = 220;
    // Don't resize - let the existing chart code handle sizing
    // Just overlay the real SAC line

    const pad = { l: 50, r: 20, t: 20, b: 40 };
    const cw = w - pad.l - pad.r;
    const ch = h - pad.t - pad.b;

    const threadCounts = results.map(r => r.threads);
    const threadIndices = [1, 2, 4, 8];

    // Draw real SAC line in green
    ctx.save();
    ctx.scale(1/dpr, 1/dpr);
    ctx.scale(dpr, dpr);

    ctx.strokeStyle = '#00b894';
    ctx.lineWidth = 2.5;
    ctx.setLineDash([]);
    ctx.beginPath();

    results.forEach((r, idx) => {
      const tIdx = threadIndices.indexOf(r.threads);
      if (tIdx === -1) return;
      const x = pad.l + (tIdx / (threadIndices.length - 1)) * cw;
      const speedup = r.speedup;
      const y = pad.t + ch - (speedup / 8) * ch;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw dots
    results.forEach((r, idx) => {
      const tIdx = threadIndices.indexOf(r.threads);
      if (tIdx === -1) return;
      const x = pad.l + (tIdx / (threadIndices.length - 1)) * cw;
      const y = pad.t + ch - (r.speedup / 8) * ch;

      ctx.fillStyle = '#00b894';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#00b894';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(r.speedup.toFixed(1) + 'x', x, y - 14);
    });

    // Label
    ctx.fillStyle = '#00b894';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Real (SAC)', pad.l + 5, pad.t + 12);

    ctx.fillStyle = '#6c5ce7';
    ctx.fillText('Simulated (JS)', pad.l + 85, pad.t + 12);

    ctx.restore();
  }

  // ---- Helpers ----

  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ---- Init ----

  createIndicator();
  startHeartbeat();
})();
</script>
</body>
</html>
